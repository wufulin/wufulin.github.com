<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Claude Code 完全指南：从入门到精通的 13+6 个核心技巧 | Franklin爱家</title><meta name="author" content="Franklin"><meta name="copyright" content="Franklin"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="深入解析 Claude Code 创始工程师的 13 个核心工作方法，以及 Plan 模式、Sandbox 模式、自定义命令等高级功能，帮助你建立高效的 AI 编程工作流。">
<meta property="og:type" content="article">
<meta property="og:title" content="Claude Code 完全指南：从入门到精通的 13+6 个核心技巧">
<meta property="og:url" content="https://wufulin.github.io/2026/01/29/claude-code-complete-guide/index.html">
<meta property="og:site_name" content="Franklin爱家">
<meta property="og:description" content="深入解析 Claude Code 创始工程师的 13 个核心工作方法，以及 Plan 模式、Sandbox 模式、自定义命令等高级功能，帮助你建立高效的 AI 编程工作流。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wufulin.github.io/img/default_cover1.jpg">
<meta property="article:published_time" content="2026-01-29T02:00:00.000Z">
<meta property="article:modified_time" content="2026-02-03T17:44:48.550Z">
<meta property="article:author" content="Franklin">
<meta property="article:tag" content="AI 编程">
<meta property="article:tag" content="Claude Code">
<meta property="article:tag" content="开发工具">
<meta property="article:tag" content="效率提升">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wufulin.github.io/img/default_cover1.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Claude Code 完全指南：从入门到精通的 13+6 个核心技巧",
  "url": "https://wufulin.github.io/2026/01/29/claude-code-complete-guide/",
  "image": "https://wufulin.github.io/img/default_cover1.jpg",
  "datePublished": "2026-01-29T02:00:00.000Z",
  "dateModified": "2026-02-03T17:44:48.550Z",
  "author": [
    {
      "@type": "Person",
      "name": "Franklin",
      "url": "https://wufulin.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://wufulin.github.io/2026/01/29/claude-code-complete-guide/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Claude Code 完全指南：从入门到精通的 13+6 个核心技巧',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="Franklin爱家" type="application/atom+xml">
</head><body><div class="bg-animation" id="web_bg" style="background-color: #F4EFEB;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fas fa-clock"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default_cover1.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Franklin爱家</span></a><a class="nav-page-title" href="/"><span class="site-name">Claude Code 完全指南：从入门到精通的 13+6 个核心技巧</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fas fa-clock"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Claude Code 完全指南：从入门到精通的 13+6 个核心技巧</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-29T02:00:00.000Z" title="发表于 2026-01-29 10:00:00">2026-01-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-02-03T17:44:48.550Z" title="更新于 2026-02-04 01:44:48">2026-02-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Claude Code 是 Anthropic 推出的智能编程助手，它不仅仅是一个聊天工具，更是一个能与你的开发环境深度集成的”编程伙伴”。本文整理了 Claude Code 创始工程师 Boris Cherny 每天实际在用的 13 个核心方法，以及高级功能和最佳实践，帮助你真正掌握这个强大的开发工具。</p>
<hr>
<h2 id="第一部分：Boris-Cherny-的-13-个核心工作方法"><a href="#第一部分：Boris-Cherny-的-13-个核心工作方法" class="headerlink" title="第一部分：Boris Cherny 的 13 个核心工作方法"></a>第一部分：Boris Cherny 的 13 个核心工作方法</h2><h3 id="方法-1-2：并行工作，榨干工具价值"><a href="#方法-1-2：并行工作，榨干工具价值" class="headerlink" title="方法 1-2：并行工作，榨干工具价值"></a>方法 1-2：并行工作，榨干工具价值</h3><p><strong>终端同时跑 5 个 Claude 实例</strong></p>
<p>Boris 在终端里同时开启 5 个 Claude 窗口，每个窗口处理不同的任务：</p>
<ul>
<li>窗口 1：正在写新功能的代码</li>
<li>窗口 2：跑测试找 Bug</li>
<li>窗口 3：查 API 文档</li>
<li>窗口 4：做代码重构</li>
<li>窗口 5：处理用户反馈</li>
</ul>
<p>关键技巧是开启系统通知功能。当某个 Claude 需要输入时，系统会弹出提醒。这样就不需要盯着某一个窗口傻等，而是可以在不同任务间灵活切换。</p>
<p><strong>网页版再开 5-10 个任务</strong></p>
<p>除了终端的 5 个窗口，Boris 还会在浏览器里打开 claude.ai&#x2F;code，再启动 5-10 个 Claude 会话。他甚至会在手机（Claude iOS 应用）上启动几个任务，然后过一会儿再去看结果。</p>
<blockquote>
<p><strong>核心逻辑</strong>：Claude 订阅费每月 200 美元。如果你只开一个窗口，就好比你花钱请了 5 个助手，但让他们排队一个个来工作。同时开多个窗口，就是让多个助手并行干活，效率成倍提升。</p>
</blockquote>
<h3 id="方法-3：永远用最强的模型"><a href="#方法-3：永远用最强的模型" class="headerlink" title="方法 3：永远用最强的模型"></a>方法 3：永远用最强的模型</h3><p>Boris 在所有任务上都用 <strong>Opus 4.5</strong> 模型，并且开启思考功能。</p>
<p>很多人可能会问：Opus 比 Sonnet 贵，速度也慢，为什么不用便宜的？</p>
<p><strong>Boris 的理由</strong>：</p>
<p>虽然 Opus 单次响应时间更长，但因为它更聪明，你需要的来回次数更少：</p>
<ul>
<li>用 Sonnet：可能要提示 3 次才能得到满意结果，每次等 30 秒，总共 90 秒</li>
<li>用 Opus：第一次就能做对，虽然要等 60 秒，但总共只需要 60 秒</li>
</ul>
<p>而且 Opus 在使用工具（读写文件、运行命令、调用 API）时更准确，更少出错。</p>
<h3 id="方法-4-5：积累团队智慧"><a href="#方法-4-5：积累团队智慧" class="headerlink" title="方法 4-5：积累团队智慧"></a>方法 4-5：积累团队智慧</h3><p><strong>团队共享 CLAUDE.md 文件</strong></p>
<p>Boris 的团队维护一个 CLAUDE.md 文件，专门记录两类信息：</p>
<ol>
<li>Claude 做错过的事情，以及正确的做法</li>
<li>团队的特殊规范和偏好</li>
</ol>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">禁止在生产代码中使用 console.log，请使用我们的 logger 工具。</span><br><span class="line">提交信息必须遵循 Conventional Commits 格式。</span><br><span class="line">所有 API 错误必须返回统一的错误格式 &#123;code, message, details&#125;。</span><br></pre></td></tr></table></figure>

<p>每当团队成员发现 Claude 做错了什么，就会在 CLAUDE.md 里加一条规则。久而久之，这个文件变成了团队的”AI 培训手册”。</p>
<p><strong>代码审查时用 @claude 更新规范</strong></p>
<p>在做代码审查时，如果发现某个问题值得记录，就在 PR 评论里 @claude，让它自动把这条规则加到 CLAUDE.md 里。</p>
<p>例如审查时发现某个 API 调用没有加 timeout，你可以评论：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@claude 请在 CLAUDE.md 中添加：所有外部 API 调用必须设置合理的 timeout。</span><br></pre></td></tr></table></figure>

<p>Claude 会自动把这条规则写进 CLAUDE.md，并作为 PR 的一部分提交。</p>
<h3 id="方法-6：用计划模式启动任务"><a href="#方法-6：用计划模式启动任务" class="headerlink" title="方法 6：用计划模式启动任务"></a>方法 6：用计划模式启动任务</h3><p>Boris 的大多数会话都是在<strong>计划模式</strong>下开始的。</p>
<p>启动计划模式的方法：<strong>按两次 Shift+Tab</strong></p>
<p>进入计划模式后，工作流程变成：</p>
<ol>
<li>你告诉 Claude 想做什么</li>
<li>Claude 给出一个计划，列出它打算怎么做</li>
<li>你审查这个计划，提意见，要求调整</li>
<li>来回几轮，直到计划让你满意</li>
<li>切换到自动接受模式，让 Claude 执行</li>
</ol>
<blockquote>
<p><strong>核心原则</strong>：花 3 分钟确认计划，能省下 30 分钟的返工时间。</p>
</blockquote>
<h3 id="方法-7：为高频工作流创建斜杠命令"><a href="#方法-7：为高频工作流创建斜杠命令" class="headerlink" title="方法 7：为高频工作流创建斜杠命令"></a>方法 7：为高频工作流创建斜杠命令</h3><p>Boris 为每个重复执行的工作流创建了斜杠命令，保存在 <code>.claude/commands/</code> 文件夹里。</p>
<p>例如 <code>/commit-push-pr</code> 命令，功能包括：</p>
<ul>
<li>查看 git 当前状态</li>
<li>生成合适的 commit message</li>
<li>提交代码</li>
<li>推送到远程仓库</li>
<li>创建 Pull Request</li>
</ul>
<p>他每天要用这个命令几十次。斜杠命令把这个流程固化下来，只需要输入 <code>/commit-push-pr</code>，剩下的全自动。</p>
<h3 id="方法-8：用子代理处理专门任务"><a href="#方法-8：用子代理处理专门任务" class="headerlink" title="方法 8：用子代理处理专门任务"></a>方法 8：用子代理处理专门任务</h3><p>Boris 创建了多个子代理（sub-agents），每个负责特定类型的任务：</p>
<ul>
<li><strong>code-simplifier</strong>：在 Claude 完成代码后，专门负责简化和优化代码</li>
<li><strong>verify-app</strong>：包含详细的测试指令，负责端到端测试应用</li>
<li><strong>security-reviewer</strong>：专注于安全问题审查</li>
<li><strong>performance-reviewer</strong>：专注于性能问题分析</li>
</ul>
<p>子代理适合需要判断和决策的任务，而斜杠命令适合固定步骤的操作。</p>
<h3 id="方法-9：用钩子自动格式化代码"><a href="#方法-9：用钩子自动格式化代码" class="headerlink" title="方法 9：用钩子自动格式化代码"></a>方法 9：用钩子自动格式化代码</h3><p>Boris 的团队用了一个 <strong>PostToolUse</strong> 钩子。每当 Claude 使用工具（比如编辑文件）后，这个钩子会自动运行代码格式化工具：</p>
<ul>
<li>Claude 写了 JavaScript 代码 → 钩子自动运行 Prettier 格式化</li>
<li>Claude 写了 Python 代码 → 钩子自动运行 Black 格式化</li>
</ul>
<p>这样就不用在 CI 环节因为格式问题报错了。</p>
<h3 id="方法-10：用权限预设避免重复确认"><a href="#方法-10：用权限预设避免重复确认" class="headerlink" title="方法 10：用权限预设避免重复确认"></a>方法 10：用权限预设避免重复确认</h3><p>Claude Code 默认会在执行敏感操作时询问许可。Boris 不用 <code>--dangerously-skip-permissions</code>（那太危险），而是用 <code>/permissions</code> 命令预先允许一些已知安全的常用命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git diff</span><br><span class="line">npm <span class="built_in">test</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="built_in">cat</span></span><br></pre></td></tr></table></figure>

<p>这些命令被写进 <code>.claude/settings.json</code> 文件，提交到 Git，团队共享。</p>
<p><strong>判断原则</strong>：</p>
<ul>
<li>只读操作 → 预设允许</li>
<li>可逆操作 → 预设允许</li>
<li>不可逆操作 → 每次确认</li>
<li>涉及外部系统 → 每次确认</li>
</ul>
<h3 id="方法-11：让-Claude-使用所有工具"><a href="#方法-11：让-Claude-使用所有工具" class="headerlink" title="方法 11：让 Claude 使用所有工具"></a>方法 11：让 Claude 使用所有工具</h3><p>Boris 给 Claude 配置了大量 MCP 服务器（Model Context Protocol），让 Claude 可以：</p>
<ul>
<li>搜索并发布消息到 Slack</li>
<li>运行 BigQuery 查询做数据分析</li>
<li>从 Sentry 获取错误日志</li>
<li>调用各种命令行工具</li>
</ul>
<p>这些配置被写在 <code>.mcp.json</code> 文件里，团队共享。</p>
<h3 id="方法-12-13：长任务处理与验证闭环"><a href="#方法-12-13：长任务处理与验证闭环" class="headerlink" title="方法 12-13：长任务处理与验证闭环"></a>方法 12-13：长任务处理与验证闭环</h3><p><strong>长任务用后台代理或插件</strong></p>
<p>对于需要运行很长时间的任务，Boris 有三种策略：</p>
<ol>
<li><strong>策略 A</strong>：让 Claude 用后台代理验证</li>
<li><strong>策略 B</strong>：用代理停止钩子自动验证</li>
<li><strong>策略 C</strong>：用专门的插件在完成任务后自动运行检查</li>
</ol>
<p>在沙箱环境里，他会用 <code>--permission-mode=dontAsk</code>，让 Claude 可以不受阻碍地完成整个长任务。</p>
<p><strong>给 Claude 验证工作的途径</strong></p>
<p>这是 Boris 认为<strong>最重要</strong>的一条：确保 Claude 有办法验证自己做的工作。</p>
<p>没有反馈循环的 AI 就像闭着眼睛干活的人，它不知道自己做得对不对。有了反馈循环，AI 可以自己检查、自己纠错、自己迭代，最终结果的质量能提升 2 到 3 倍。</p>
<hr>
<h2 id="第二部分：高级功能详解"><a href="#第二部分：高级功能详解" class="headerlink" title="第二部分：高级功能详解"></a>第二部分：高级功能详解</h2><h3 id="4-1-Plan-模式（规划模式）"><a href="#4-1-Plan-模式（规划模式）" class="headerlink" title="4.1 Plan 模式（规划模式）"></a>4.1 Plan 模式（规划模式）</h3><p>Plan 模式是一种”先规划、后执行”的工作模式。Anthropic 开发者关系负责人 Ado Kukic 有 90% 的时间都在使用这个模式。</p>
<p><strong>进入 Plan 模式</strong>：</p>
<ul>
<li>快捷键：按两次 Shift+Tab</li>
<li>命令：<code>/plan</code></li>
</ul>
<p><strong>核心价值</strong>：在这个模式下，Claude 会阅读代码、分析架构、起草计划，但绝不修改代码。直到你批准计划，它才会动手。你是架构师，它是执行者。</p>
<p><strong>适合场景</strong>：</p>
<ul>
<li>✅ 复杂功能开发（多文件、多步骤）</li>
<li>✅ 架构重构</li>
<li>✅ 性能优化</li>
<li>✅ 代码迁移</li>
<li>❌ 简单 Bug 修复、单行代码修改</li>
</ul>
<h3 id="4-2-Sandbox-模式（沙箱模式）"><a href="#4-2-Sandbox-模式（沙箱模式）" class="headerlink" title="4.2 Sandbox 模式（沙箱模式）"></a>4.2 Sandbox 模式（沙箱模式）</h3><p>Sandbox 模式通过定义允许的操作范围，拦截危险操作，提高安全性。</p>
<p><strong>配置方式</strong>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;permissions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;allow&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;bash&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;npm install&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;npm test&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;npm run build&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;git *&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;write&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;src/**/*&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;tests/**/*&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;deny&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;bash&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;rm -rf *&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;format *&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;shutdown&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-Headless-模式（无头模式）"><a href="#4-3-Headless-模式（无头模式）" class="headerlink" title="4.3 Headless 模式（无头模式）"></a>4.3 Headless 模式（无头模式）</h3><p>Headless 模式是非交互式运行方式，可集成到 Shell 脚本或 CI&#x2F;CD 流程中。</p>
<p><strong>使用场景</strong>：</p>
<ul>
<li>🔄 CI&#x2F;CD 集成（自动化代码审查）</li>
<li>📜 脚本自动化（批量处理任务）</li>
<li>🔍 快速分析（不需要交互的代码分析）</li>
</ul>
<p><strong>基本用法</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从管道输入</span></span><br><span class="line">git diff | claude -p <span class="string">&quot;解释这些更改&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接指定</span></span><br><span class="line">claude -p <span class="string">&quot;检查代码质量&quot;</span> &lt; src/main.js</span><br></pre></td></tr></table></figure>

<h3 id="4-4-Slash-Commands（自定义命令）"><a href="#4-4-Slash-Commands（自定义命令）" class="headerlink" title="4.4 Slash Commands（自定义命令）"></a>4.4 Slash Commands（自定义命令）</h3><p>Slash Commands 是将高频工作流封装成可复用的斜杠命令。</p>
<p><strong>创建方式</strong>：<br>在 <code>.claude/commands/</code> 目录创建 Markdown 文件：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># .claude/commands/commit-push-pr.md</span></span><br><span class="line"></span><br><span class="line">你是一个发布助手。请执行以下步骤：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 检查 Git 状态</span><br><span class="line">   !git status</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 运行测试套件</span><br><span class="line">   !npm test</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 如果测试通过：</span><br><span class="line"><span class="bullet">   -</span> 添加所有更改</span><br><span class="line"><span class="bullet">   -</span> 生成符合 Conventional Commits 的提交消息</span><br><span class="line"><span class="bullet">   -</span> 推送到远程</span><br><span class="line"><span class="bullet">   -</span> 创建 Pull Request</span><br></pre></td></tr></table></figure>

<p>使用：直接输入 <code>/commit-push-pr</code></p>
<h3 id="4-5-Extended-Thinking（扩展思考模式）"><a href="#4-5-Extended-Thinking（扩展思考模式）" class="headerlink" title="4.5 Extended Thinking（扩展思考模式）"></a>4.5 Extended Thinking（扩展思考模式）</h3><p>当你需要设计复杂的缓存层或重构架构时，在提示词中加上 <code>ultrathink</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ultrathink: 设计一个高可用的 Redis 缓存层，考虑：</span><br><span class="line">- 缓存穿透、缓存击穿、缓存雪崩</span><br><span class="line">- 分布式锁</span><br><span class="line">- 缓存更新策略</span><br><span class="line">- 降级方案</span><br></pre></td></tr></table></figure>

<p>效果：Claude 会分配高达 32k 的 Token 进行内部推理，逻辑准确率大幅提升。</p>
<hr>
<h2 id="第三部分：实用技巧与快捷操作"><a href="#第三部分：实用技巧与快捷操作" class="headerlink" title="第三部分：实用技巧与快捷操作"></a>第三部分：实用技巧与快捷操作</h2><h3 id="基础操作技巧"><a href="#基础操作技巧" class="headerlink" title="基础操作技巧"></a>基础操作技巧</h3><table>
<thead>
<tr>
<th>操作</th>
<th>命令&#x2F;快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>项目初始化</td>
<td><code>/init</code></td>
</tr>
<tr>
<td>快速引用文件</td>
<td><code>@src/auth.ts</code></td>
</tr>
<tr>
<td>引用整个目录</td>
<td><code>@src/components/</code></td>
</tr>
<tr>
<td>即时执行 Bash</td>
<td><code>!git status</code></td>
</tr>
<tr>
<td>回退操作</td>
<td>双击 ESC</td>
</tr>
<tr>
<td>反向搜索历史</td>
<td>Ctrl + R</td>
</tr>
<tr>
<td>提示词暂存</td>
<td>Ctrl + S</td>
</tr>
</tbody></table>
<h3 id="会话管理技巧"><a href="#会话管理技巧" class="headerlink" title="会话管理技巧"></a>会话管理技巧</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 恢复上一次对话</span></span><br><span class="line">claude --<span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示历史会话列表</span></span><br><span class="line">claude --resume</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给当前会话命名</span></span><br><span class="line">/rename feature-auth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按名称恢复会话</span></span><br><span class="line">/resume feature-auth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在终端和网页间同步上下文</span></span><br><span class="line">claude --teleport session_id</span><br></pre></td></tr></table></figure>

<h3 id="常用斜杠命令速查"><a href="#常用斜杠命令速查" class="headerlink" title="常用斜杠命令速查"></a>常用斜杠命令速查</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>使用频率</th>
</tr>
</thead>
<tbody><tr>
<td><code>/clear</code></td>
<td>清空对话历史</td>
<td>⭐⭐⭐⭐⭐</td>
</tr>
<tr>
<td><code>/compact</code></td>
<td>清空对话但保留摘要</td>
<td>⭐⭐⭐⭐⭐</td>
</tr>
<tr>
<td><code>/context</code></td>
<td>可视化上下文使用</td>
<td>⭐⭐⭐⭐⭐</td>
</tr>
<tr>
<td><code>/model</code></td>
<td>切换模型</td>
<td>⭐⭐⭐⭐</td>
</tr>
<tr>
<td><code>/cost</code></td>
<td>显示费用统计</td>
<td>⭐⭐⭐⭐</td>
</tr>
<tr>
<td><code>/export</code></td>
<td>导出对话</td>
<td>⭐⭐⭐⭐</td>
</tr>
</tbody></table>
<hr>
<h2 id="第四部分：最佳实践"><a href="#第四部分：最佳实践" class="headerlink" title="第四部分：最佳实践"></a>第四部分：最佳实践</h2><h3 id="模型选择策略"><a href="#模型选择策略" class="headerlink" title="模型选择策略"></a>模型选择策略</h3><p><strong>国外模型</strong>：</p>
<ul>
<li>快速查询&#x2F;格式化：<strong>Haiku 4.5</strong> - 最快最便宜</li>
<li>日常开发&#x2F;代码编写：<strong>Sonnet 4.5</strong> - 性价比平衡</li>
<li>架构设计&#x2F;复杂重构：<strong>Opus 4.5 + Thinking</strong> - 最高质量（创始人首选）</li>
</ul>
<p><strong>国内模型</strong>：</p>
<ul>
<li>简单查询：<strong>DeepSeek-Coder</strong> - 极低成本</li>
<li>中文项目：<strong>GLM-4.7</strong> - 中文理解最强</li>
<li>大型重构：<strong>Kimi K2</strong> - 超长上下文（2M+）</li>
<li>Python&#x2F;JS：<strong>Qwen-Coder-Plus</strong> - 开源优秀</li>
</ul>
<h3 id="验证闭环（Feedback-Loop）"><a href="#验证闭环（Feedback-Loop）" class="headerlink" title="验证闭环（Feedback Loop）"></a>验证闭环（Feedback Loop）</h3><p>来自 Boris 的最重要技巧：<strong>永远给 Claude 一种验证自己工作的方法</strong>。</p>
<p>如果 Claude 能看到自己代码的运行结果（报错信息、测试通过与否），它的代码质量会提升 2-3 倍。</p>
<p><strong>实践方法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请实现一个用户登录功能，然后：</span><br><span class="line">1. 运行测试验证</span><br><span class="line">!npm test</span><br><span class="line">2. 根据测试结果修复问题</span><br><span class="line">3. 重新验证直到所有测试通过</span><br></pre></td></tr></table></figure>

<h3 id="探索-规划-编码-提交工作流"><a href="#探索-规划-编码-提交工作流" class="headerlink" title="探索-规划-编码-提交工作流"></a>探索-规划-编码-提交工作流</h3><p><strong>第 1 步：探索阶段</strong> - 理解项目架构<br><strong>第 2 步：规划阶段</strong> - 使用 Plan 模式设计实现方案<br><strong>第 3 步：编码阶段</strong> - 按计划实施<br><strong>第 4 步：提交阶段</strong> - 使用 commit skill 生成规范的 commit message</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这 13+6 个方法围绕着几个核心思想：</p>
<ol>
<li><strong>并行工作，榨干工具价值</strong>（方法 1、2）</li>
<li><strong>用最好的模型，追求一次做对</strong>（方法 3）</li>
<li><strong>积累团队智慧，让 AI 越用越聪明</strong>（方法 4、5、11）</li>
<li><strong>自动化一切重复操作</strong>（方法 7、8、9、10）</li>
<li><strong>给 AI 完整的工具和权限</strong>（方法 10、11、12）</li>
<li><strong>建立反馈循环，让 AI 自我验证</strong>（方法 13）</li>
<li><strong>先计划再执行，方向比速度重要</strong>（方法 6、Plan 模式）</li>
</ol>
<p>这些方法不是随便想出来的，是 Boris 和他的团队在实际工作中不断试错总结出来的。你不需要一次全部用上，可以先从最适合你的几条开始，慢慢建立自己的 AI 工作流。</p>
<p>关键是要有这个意识：AI 工具不是拿来就能用好的，需要你投入时间去配置、训练、优化。但一旦建立起顺手的工作流，回报是巨大的。</p>
<p>就像 Boris 说的：<strong>Claude Code 没有唯一正确的用法，团队里每个人都在用不同的方式。重要的是找到适合你的方式，然后不断迭代改进。</strong></p>
<hr>
<p><em>本文部分内容结合个人实践经验整理而成。</em></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://wufulin.github.io">Franklin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://wufulin.github.io/2026/01/29/claude-code-complete-guide/">https://wufulin.github.io/2026/01/29/claude-code-complete-guide/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://wufulin.github.io" target="_blank">Franklin爱家</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Claude-Code/">Claude Code</a><a class="post-meta__tags" href="/tags/AI-%E7%BC%96%E7%A8%8B/">AI 编程</a><a class="post-meta__tags" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/">开发工具</a><a class="post-meta__tags" href="/tags/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87/">效率提升</a></div><div class="post-share"><div class="social-share" data-image="/img/default_cover1.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/01/30/moltbot-memory-mechanism/" title="Moltbot记忆机制深度解析：本地优先的AI长期记忆架构"><img class="cover" src="/img/default_cover6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Moltbot记忆机制深度解析：本地优先的AI长期记忆架构</div></div><div class="info-2"><div class="info-item-1">引言在 AI 助手领域，记忆一直是制约用户体验的核心瓶颈。传统的 ChatGPT、Claude 等对话系统，每次新会话都是”从零开始”，用户不得不反复提供背景信息。Moltbot（原 Clawdbot）的出现彻底改变了这一局面，其独特的本地优先长期记忆架构让 AI 真正拥有了”永不遗忘”的能力。 本文将深入剖析 Moltbot 记忆机制的技术原理，揭示其如何通过 Markdown 文件系统、语义检索层和智能上下文管理，构建出一个既私密又强大的个人记忆库。 一、传统AI记忆的困境1.1 上下文窗口的局限大语言模型（LLM）的”记忆”本质上是一个滑动窗口: 123[系统提示] + [历史对话] + [当前输入] → LLM → [输出]         ↑___________________↑              上下文窗口  当对话长度超过窗口限制（如 8K、32K、200K tokens），早期的信息就会被丢弃。这种”失忆”导致:  跨会话无法保持连贯性 重要细节容易被遗忘 用户需要不断重复背景信息  1.2 云端记忆的隐私风险部分 AI 产品提供”云端记忆”功能，但这意...</div></div></div></a><a class="pagination-related" href="/2026/01/27/moltbot-tutorial/" title="Moltbot完全指南:打造你的24/7个人AI助手"><img class="cover" src="/img/default_cover7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Moltbot完全指南:打造你的24/7个人AI助手</div></div><div class="info-2"><div class="info-item-1">前言想象一下,如果有一个 AI 助手,能够在你常用的任何聊天软件中随时待命,记得你说的每一句话,还能主动提醒你重要事项——这不是科幻电影,而是Moltbot正在实现的未来。 2026 年开年,Moltbot 作为一个开源个人 AI 助手项目引爆了技术圈,甚至让 Mac mini 一度卖断货。它让 Claude、GPT 等大模型 AI 真正融入我们的日常工作和生活,成为第一个”有记忆、会主动”的 AI 助手。 本文将带你从零开始,全面了解 Moltbot 的核心功能,并手把手教你搭建属于自己的 AI 助手。 一、什么是 Moltbot?核心定义Moltbot是由 Peter Steinberger(PSPDFKit 创始人)开发的开源个人 AI 助手框架。与传统 AI 聊天机器人不同,Moltbot 采用”无处不在“的设计理念——它直接运行在你熟悉的聊天软件中。 核心特点对比   特性 Moltbot 传统 AI 聊天    使用方式 在常用聊天软件内使用 需要打开专门网页或 APP   对话记忆 跨平台持久记忆(MD 文件) 每次对话独立,云端存储   主动服务 支持定时提醒和主...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2026/02/03/oh-my-opencode-complete-guide/" title="Oh-My-OpenCode 完全指南：多代理协作编程新范式"><img class="cover" src="/img/default_cover9.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-03</div><div class="info-item-2">Oh-My-OpenCode 完全指南：多代理协作编程新范式</div></div><div class="info-2"><div class="info-item-1">前言如果说 Claude Code 是单个 AI 编程助手的巅峰之作，那么 Oh-My-OpenCode（OMO） 就是将 AI 编程推向全新维度的革命性插件。它将单个 AI 代理升级为多代理协作团队，让 11 个专业代理并行工作，像一支训练有素的开发团队一样协作编码。 本文基于 OMO v3.2.1 版本（最新版，包含 Hephaestus 代理和多项性能优化），从零基础开始，带你全面了解这个强大的多代理编程框架。  一、什么是 Oh-My-OpenCode？核心定位Oh-My-OpenCode 是 OpenCode 的顶级插件。OpenCode 本身是一个开源 AI 编码代理（类似 Claude Code &#x2F; Cursor 的开源替代），而 OMO 在其基础上添加了编排层，让多个专业代理能够像”小团队”一样协作完成任务。 核心理念对比   维度 传统 AI 编码助手 Oh-My-OpenCode    工作模式 单代理串行处理 多代理并行协作   任务分配 所有工作一个代理做 专业代理各司其职   规划能力 边做边想 先规划后执行   执行效率 线性处理 多线程并行...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Franklin</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/wufulin" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9ABoris-Cherny-%E7%9A%84-13-%E4%B8%AA%E6%A0%B8%E5%BF%83%E5%B7%A5%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">第一部分：Boris Cherny 的 13 个核心工作方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-1-2%EF%BC%9A%E5%B9%B6%E8%A1%8C%E5%B7%A5%E4%BD%9C%EF%BC%8C%E6%A6%A8%E5%B9%B2%E5%B7%A5%E5%85%B7%E4%BB%B7%E5%80%BC"><span class="toc-number">2.1.</span> <span class="toc-text">方法 1-2：并行工作，榨干工具价值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-3%EF%BC%9A%E6%B0%B8%E8%BF%9C%E7%94%A8%E6%9C%80%E5%BC%BA%E7%9A%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">方法 3：永远用最强的模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-4-5%EF%BC%9A%E7%A7%AF%E7%B4%AF%E5%9B%A2%E9%98%9F%E6%99%BA%E6%85%A7"><span class="toc-number">2.3.</span> <span class="toc-text">方法 4-5：积累团队智慧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-6%EF%BC%9A%E7%94%A8%E8%AE%A1%E5%88%92%E6%A8%A1%E5%BC%8F%E5%90%AF%E5%8A%A8%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.4.</span> <span class="toc-text">方法 6：用计划模式启动任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-7%EF%BC%9A%E4%B8%BA%E9%AB%98%E9%A2%91%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%88%9B%E5%BB%BA%E6%96%9C%E6%9D%A0%E5%91%BD%E4%BB%A4"><span class="toc-number">2.5.</span> <span class="toc-text">方法 7：为高频工作流创建斜杠命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-8%EF%BC%9A%E7%94%A8%E5%AD%90%E4%BB%A3%E7%90%86%E5%A4%84%E7%90%86%E4%B8%93%E9%97%A8%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.6.</span> <span class="toc-text">方法 8：用子代理处理专门任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-9%EF%BC%9A%E7%94%A8%E9%92%A9%E5%AD%90%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81"><span class="toc-number">2.7.</span> <span class="toc-text">方法 9：用钩子自动格式化代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-10%EF%BC%9A%E7%94%A8%E6%9D%83%E9%99%90%E9%A2%84%E8%AE%BE%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E7%A1%AE%E8%AE%A4"><span class="toc-number">2.8.</span> <span class="toc-text">方法 10：用权限预设避免重复确认</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-11%EF%BC%9A%E8%AE%A9-Claude-%E4%BD%BF%E7%94%A8%E6%89%80%E6%9C%89%E5%B7%A5%E5%85%B7"><span class="toc-number">2.9.</span> <span class="toc-text">方法 11：让 Claude 使用所有工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-12-13%EF%BC%9A%E9%95%BF%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E4%B8%8E%E9%AA%8C%E8%AF%81%E9%97%AD%E7%8E%AF"><span class="toc-number">2.10.</span> <span class="toc-text">方法 12-13：长任务处理与验证闭环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">第二部分：高级功能详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Plan-%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%A7%84%E5%88%92%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">4.1 Plan 模式（规划模式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Sandbox-%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%B2%99%E7%AE%B1%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">4.2 Sandbox 模式（沙箱模式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Headless-%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%97%A0%E5%A4%B4%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">4.3 Headless 模式（无头模式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Slash-Commands%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">4.4 Slash Commands（自定义命令）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-Extended-Thinking%EF%BC%88%E6%89%A9%E5%B1%95%E6%80%9D%E8%80%83%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">4.5 Extended Thinking（扩展思考模式）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9A%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text">第三部分：实用技巧与快捷操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7"><span class="toc-number">4.1.</span> <span class="toc-text">基础操作技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E6%8A%80%E5%B7%A7"><span class="toc-number">4.2.</span> <span class="toc-text">会话管理技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%9C%E6%9D%A0%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5"><span class="toc-number">4.3.</span> <span class="toc-text">常用斜杠命令速查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%EF%BC%9A%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">5.</span> <span class="toc-text">第四部分：最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5"><span class="toc-number">5.1.</span> <span class="toc-text">模型选择策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E9%97%AD%E7%8E%AF%EF%BC%88Feedback-Loop%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">验证闭环（Feedback Loop）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A2%E7%B4%A2-%E8%A7%84%E5%88%92-%E7%BC%96%E7%A0%81-%E6%8F%90%E4%BA%A4%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-number">5.3.</span> <span class="toc-text">探索-规划-编码-提交工作流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/02/03/oh-my-opencode-complete-guide/" title="Oh-My-OpenCode 完全指南：多代理协作编程新范式"><img src="/img/default_cover9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Oh-My-OpenCode 完全指南：多代理协作编程新范式"/></a><div class="content"><a class="title" href="/2026/02/03/oh-my-opencode-complete-guide/" title="Oh-My-OpenCode 完全指南：多代理协作编程新范式">Oh-My-OpenCode 完全指南：多代理协作编程新范式</a><time datetime="2026-02-03T10:00:00.000Z" title="发表于 2026-02-03 18:00:00">2026-02-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/30/moltbot-memory-mechanism/" title="Moltbot记忆机制深度解析：本地优先的AI长期记忆架构"><img src="/img/default_cover6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Moltbot记忆机制深度解析：本地优先的AI长期记忆架构"/></a><div class="content"><a class="title" href="/2026/01/30/moltbot-memory-mechanism/" title="Moltbot记忆机制深度解析：本地优先的AI长期记忆架构">Moltbot记忆机制深度解析：本地优先的AI长期记忆架构</a><time datetime="2026-01-30T06:00:00.000Z" title="发表于 2026-01-30 14:00:00">2026-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/29/claude-code-complete-guide/" title="Claude Code 完全指南：从入门到精通的 13+6 个核心技巧"><img src="/img/default_cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Claude Code 完全指南：从入门到精通的 13+6 个核心技巧"/></a><div class="content"><a class="title" href="/2026/01/29/claude-code-complete-guide/" title="Claude Code 完全指南：从入门到精通的 13+6 个核心技巧">Claude Code 完全指南：从入门到精通的 13+6 个核心技巧</a><time datetime="2026-01-29T02:00:00.000Z" title="发表于 2026-01-29 10:00:00">2026-01-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/27/moltbot-tutorial/" title="Moltbot完全指南:打造你的24/7个人AI助手"><img src="/img/default_cover7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Moltbot完全指南:打造你的24/7个人AI助手"/></a><div class="content"><a class="title" href="/2026/01/27/moltbot-tutorial/" title="Moltbot完全指南:打造你的24/7个人AI助手">Moltbot完全指南:打造你的24/7个人AI助手</a><time datetime="2026-01-27T04:00:00.000Z" title="发表于 2026-01-27 12:00:00">2026-01-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/footer_bg.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By Franklin</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? '' : ''

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: '',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.44/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>